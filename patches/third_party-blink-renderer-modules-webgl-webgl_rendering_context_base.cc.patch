diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index 39d00937e8a17183c22dcfc99692aed9a8638ac6..b38657021c277f002287222650c2f037625b3d19 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -31,6 +31,7 @@
 #include "base/feature_list.h"
 #include "base/numerics/checked_math.h"
 #include "base/stl_util.h"
+#include "brave/renderer/brave_content_settings_agent_impl_helper.h"
 #include "build/build_config.h"
 #include "gpu/GLES2/gl2extchromium.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
@@ -118,6 +119,10 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_utf8_adaptor.h"
 #include "third_party/blink/renderer/platform/wtf/threading_primitives.h"
 
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+#include "brave/third_party/blink/brave_page_graph/page_graph.h"
+// #endif
+
 namespace blink {
 
 bool WebGLRenderingContextBase::webgl_context_limits_initialized_ = false;
@@ -2836,6 +2841,8 @@ WebGLActiveInfo* WebGLRenderingContextBase::getActiveAttrib(
     GLuint index) {
   if (!ValidateWebGLProgramOrShader("getActiveAttrib", program))
     return nullptr;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return nullptr;
   GLuint program_id = ObjectNonZero(program);
   GLint max_name_length = -1;
   ContextGL()->GetProgramiv(program_id, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH,
@@ -2867,6 +2874,8 @@ WebGLActiveInfo* WebGLRenderingContextBase::getActiveUniform(
     GLuint index) {
   if (!ValidateWebGLProgramOrShader("getActiveUniform", program))
     return nullptr;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return nullptr;
   GLuint program_id = ObjectNonZero(program);
   GLint max_name_length = -1;
   ContextGL()->GetProgramiv(program_id, GL_ACTIVE_UNIFORM_MAX_LENGTH,
@@ -2897,6 +2906,8 @@ base::Optional<HeapVector<Member<WebGLShader>>>
 WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program) {
   if (!ValidateWebGLProgramOrShader("getAttachedShaders", program))
     return base::nullopt;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return base::nullopt;
 
   HeapVector<Member<WebGLShader>> shader_objects;
   const GLenum kShaderType[] = {GL_VERTEX_SHADER, GL_FRAGMENT_SHADER,
@@ -2913,6 +2924,8 @@ GLint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program,
                                                    const String& name) {
   if (!ValidateWebGLProgramOrShader("getAttribLocation", program))
     return -1;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return -1;
   if (!ValidateLocationLength("getAttribLocation", name))
     return -1;
   if (!ValidateString("getAttribLocation", name))
@@ -2946,6 +2959,8 @@ ScriptValue WebGLRenderingContextBase::getBufferParameter(
     GLenum pname) {
   if (isContextLost() || !ValidateBufferTarget("getBufferParameter", target))
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
 
   switch (pname) {
     case GL_BUFFER_USAGE: {
@@ -2971,6 +2986,8 @@ WebGLContextAttributes* WebGLRenderingContextBase::getContextAttributes()
     const {
   if (isContextLost())
     return nullptr;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return nullptr;
 
   WebGLContextAttributes* result =
       ToWebGLContextAttributes(CreationAttributes());
@@ -3068,7 +3085,25 @@ ScriptValue WebGLRenderingContextBase::getExtension(ScriptState* script_state,
       ToV8(extension, script_state->GetContext()->Global(),
            script_state->GetIsolate());
 
-  return ScriptValue(script_state->GetIsolate(), wrapped_extension);
+  ScriptValue result(script_state->GetIsolate(), wrapped_extension);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+  {
+    brave_page_graph::PageGraph* page_graph =
+      canvas()->GetDocument().GetPageGraph();
+    if (page_graph != nullptr) {
+      std::vector<const String> args;
+      args.push_back(name);
+      page_graph->RegisterWebAPICall("WebGLRenderingContext.getExtension",
+        args);
+
+      String page_graph_result;
+      result.ToString(page_graph_result);
+      page_graph->RegisterWebAPIResult("WebGLRenderingContext.getExtension",
+        page_graph_result);
+    }
+  }
+// #endif
+  return result;
 }
 
 ScriptValue WebGLRenderingContextBase::getFramebufferAttachmentParameter(
@@ -3081,6 +3116,9 @@ ScriptValue WebGLRenderingContextBase::getFramebufferAttachmentParameter(
                                          target, attachment))
     return ScriptValue::CreateNull(script_state->GetIsolate());
 
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
+
   if (!framebuffer_binding_ || !framebuffer_binding_->Object()) {
     SynthesizeGLError(GL_INVALID_OPERATION, "getFramebufferAttachmentParameter",
                       "no framebuffer bound");
@@ -3167,13 +3205,74 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_ACTIVE_TEXTURE:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_ALIASED_LINE_WIDTH_RANGE:
-      return GetWebGLFloatArrayParameter(script_state, pname);
+      {
+        ScriptValue result = GetWebGLFloatArrayParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.ALIASED_LINE_WIDTH_RANGE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_ALIASED_POINT_SIZE_RANGE:
-      return GetWebGLFloatArrayParameter(script_state, pname);
+      {
+        ScriptValue result = GetWebGLFloatArrayParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.ALIASED_POINT_SIZE_RANGE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_ALPHA_BITS:
-      if (drawing_buffer_->RequiresAlphaChannelToBePreserved())
-        return WebGLAny(script_state, 0);
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result =
+          drawing_buffer_->RequiresAlphaChannelToBePreserved()
+            ? WebGLAny(script_state, 0)
+            : GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.ALPHA_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_ARRAY_BUFFER_BINDING:
       return WebGLAny(script_state, bound_array_buffer_.Get());
     case GL_BLEND:
@@ -3193,7 +3292,27 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_BLEND_SRC_RGB:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_BLUE_BITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.BLUE_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_COLOR_CLEAR_VALUE:
       return GetWebGLFloatArrayParameter(script_state, pname);
     case GL_COLOR_WRITEMASK:
@@ -3209,9 +3328,30 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_CURRENT_PROGRAM:
       return WebGLAny(script_state, current_program_.Get());
     case GL_DEPTH_BITS:
-      if (!framebuffer_binding_ && !CreationAttributes().depth)
-        return WebGLAny(script_state, kIntZero);
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result =
+          !framebuffer_binding_ && !CreationAttributes().depth
+            ? WebGLAny(script_state, kIntZero)
+            : GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.DEPTH_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_DEPTH_CLEAR_VALUE:
       return GetFloatParameter(script_state, pname);
     case GL_DEPTH_FUNC:
@@ -3234,7 +3374,27 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_GENERATE_MIPMAP_HINT:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_GREEN_BITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.GREEN_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+        return result;
+      }
+// #endif
     case GL_IMPLEMENTATION_COLOR_READ_FORMAT:
       return GetIntParameter(script_state, pname);
     case GL_IMPLEMENTATION_COLOR_READ_TYPE:
@@ -3242,26 +3402,247 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_LINE_WIDTH:
       return GetFloatParameter(script_state, pname);
     case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_CUBE_MAP_TEXTURE_SIZE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_FRAGMENT_UNIFORM_VECTORS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_FRAGMENT_UNIFORM_VECTORS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_RENDERBUFFER_SIZE:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_RENDERBUFFER_SIZE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_TEXTURE_IMAGE_UNITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_TEXTURE_IMAGE_UNITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_TEXTURE_SIZE:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_TEXTURE_SIZE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VARYING_VECTORS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VARYING_VECTORS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VERTEX_ATTRIBS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VERTEX_ATTRIBS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VERTEX_UNIFORM_VECTORS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VERTEX_UNIFORM_VECTORS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VIEWPORT_DIMS:
+      {
+        ScriptValue result = GetWebGLIntArrayParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VIEWPORT_DIMS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
       return GetWebGLIntArrayParameter(script_state, pname);
     case GL_NUM_SHADER_BINARY_FORMATS:
       // FIXME: should we always return 0 for this?
@@ -3275,11 +3656,51 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_POLYGON_OFFSET_UNITS:
       return GetFloatParameter(script_state, pname);
     case GL_RED_BITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.RED_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_RENDERBUFFER_BINDING:
       return WebGLAny(script_state, renderbuffer_binding_.Get());
     case GL_RENDERER:
-      return WebGLAny(script_state, String("WebKit WebGL"));
+      {
+        ScriptValue result = WebGLAny(script_state, String("WebKit WebGL"));
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.RENDERER");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_SAMPLE_ALPHA_TO_COVERAGE:
       return GetBooleanParameter(script_state, pname);
     case GL_SAMPLE_BUFFERS:
@@ -3297,11 +3718,31 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_SCISSOR_TEST:
       return GetBooleanParameter(script_state, pname);
     case GL_SHADING_LANGUAGE_VERSION:
-      return WebGLAny(
+      {
+        ScriptValue result = WebGLAny(
           script_state,
           "WebGL GLSL ES 1.0 (" +
               String(ContextGL()->GetString(GL_SHADING_LANGUAGE_VERSION)) +
               ")");
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.SHADING_LANGUAGE_VERSION");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_STENCIL_BACK_FAIL:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_STENCIL_BACK_FUNC:
@@ -3317,9 +3758,30 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_STENCIL_BACK_WRITEMASK:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_STENCIL_BITS:
-      if (!framebuffer_binding_ && !CreationAttributes().stencil)
-        return WebGLAny(script_state, kIntZero);
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result =
+          !framebuffer_binding_ && !CreationAttributes().stencil
+            ? WebGLAny(script_state, kIntZero)
+            : GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.STENCIL_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_STENCIL_CLEAR_VALUE:
       return GetIntParameter(script_state, pname);
     case GL_STENCIL_FAIL:
@@ -3357,11 +3819,51 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GC3D_UNPACK_COLORSPACE_CONVERSION_WEBGL:
       return WebGLAny(script_state, unpack_colorspace_conversion_);
     case GL_VENDOR:
-      return WebGLAny(script_state, String("WebKit"));
+      {
+        ScriptValue result = WebGLAny(script_state, String("WebKit"));
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.VENDOR");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_VERSION:
-      return WebGLAny(
+      {
+        ScriptValue result = WebGLAny(
           script_state,
           "WebGL 1.0 (" + String(ContextGL()->GetString(GL_VERSION)) + ")");
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.VERSION");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_VIEWPORT:
       return GetWebGLIntArrayParameter(script_state, pname);
     case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:  // OES_standard_derivatives
@@ -3373,21 +3875,69 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
           "invalid parameter name, OES_standard_derivatives not enabled");
       return ScriptValue::CreateNull(script_state->GetIsolate());
     case WebGLDebugRendererInfo::kUnmaskedRendererWebgl:
-      if (ExtensionEnabled(kWebGLDebugRendererInfoName))
-        return WebGLAny(script_state,
-                        String(ContextGL()->GetString(GL_RENDERER)));
-      SynthesizeGLError(
-          GL_INVALID_ENUM, "getParameter",
-          "invalid parameter name, WEBGL_debug_renderer_info not enabled");
-      return ScriptValue::CreateNull(script_state->GetIsolate());
+      BRAVE_WEBGL_GET_PARAMETER_UNMASKED_RENDERER
+      {
+        ScriptValue result;
+        if (ExtensionEnabled(kWebGLDebugRendererInfoName)) {
+          result = WebGLAny(script_state,
+                            String(ContextGL()->GetString(GL_RENDERER)));
+        } else {
+          SynthesizeGLError(
+              GL_INVALID_ENUM, "getParameter",
+              "invalid parameter name, WEBGL_debug_renderer_info not enabled");
+          result = ScriptValue::CreateNull(script_state->GetIsolate());
+        }
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("ext.UNMASKED_RENDERER_WEBGL");
+            page_graph->RegisterWebAPICall(
+              "WebGLRenderingContext.getParameter", args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case WebGLDebugRendererInfo::kUnmaskedVendorWebgl:
-      if (ExtensionEnabled(kWebGLDebugRendererInfoName))
-        return WebGLAny(script_state,
-                        String(ContextGL()->GetString(GL_VENDOR)));
-      SynthesizeGLError(
-          GL_INVALID_ENUM, "getParameter",
-          "invalid parameter name, WEBGL_debug_renderer_info not enabled");
-      return ScriptValue::CreateNull(script_state->GetIsolate());
+      BRAVE_WEBGL_GET_PARAMETER_UNMASKED_VENDOR
+      {
+        ScriptValue result;
+        if (ExtensionEnabled(kWebGLDebugRendererInfoName)) {
+          result = WebGLAny(script_state,
+                            String(ContextGL()->GetString(GL_VENDOR)));
+        } else {
+          SynthesizeGLError(
+              GL_INVALID_ENUM, "getParameter",
+              "invalid parameter name, WEBGL_debug_renderer_info not enabled");
+          result = ScriptValue::CreateNull(script_state->GetIsolate());
+        }
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("ext.UNMASKED_VENDOR_WEBGL");
+            page_graph->RegisterWebAPICall(
+              "WebGLRenderingContext.getParameter", args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_VERTEX_ARRAY_BINDING_OES:  // OES_vertex_array_object
       if (ExtensionEnabled(kOESVertexArrayObjectName) || IsWebGL2OrHigher()) {
         if (!bound_vertex_array_object_->IsDefaultObject())
@@ -3399,14 +3949,37 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
           "invalid parameter name, OES_vertex_array_object not enabled");
       return ScriptValue::CreateNull(script_state->GetIsolate());
     case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:  // EXT_texture_filter_anisotropic
-      if (ExtensionEnabled(kEXTTextureFilterAnisotropicName)) {
-        return GetFloatParameter(script_state,
-                                 GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
+      {
+        ScriptValue result;
+        if (ExtensionEnabled(kEXTTextureFilterAnisotropicName)) {
+          result = GetFloatParameter(script_state,
+                                     GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
+        } else {
+          SynthesizeGLError(
+              GL_INVALID_ENUM, "getParameter",
+              "invalid parameter name, "
+              "EXT_texture_filter_anisotropic not enabled");
+          result = ScriptValue::CreateNull(script_state->GetIsolate());
+        }
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            canvas()->GetDocument().GetPageGraph();
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT");
+            page_graph->RegisterWebAPICall(
+              "WebGLRenderingContext.getParameter", args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
       }
-      SynthesizeGLError(
-          GL_INVALID_ENUM, "getParameter",
-          "invalid parameter name, EXT_texture_filter_anisotropic not enabled");
-      return ScriptValue::CreateNull(script_state->GetIsolate());
     case GL_MAX_COLOR_ATTACHMENTS_EXT:  // EXT_draw_buffers BEGIN
       if (ExtensionEnabled(kWebGLDrawBuffersName) || IsWebGL2OrHigher())
         return WebGLAny(script_state, MaxColorAttachments());
@@ -3462,10 +4035,11 @@ ScriptValue WebGLRenderingContextBase::getProgramParameter(
     ScriptState* script_state,
     WebGLProgram* program,
     GLenum pname) {
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
   if (!ValidateWebGLProgramOrShader("getProgramParamter", program)) {
     return ScriptValue::CreateNull(script_state->GetIsolate());
   }
-
   GLint value = 0;
   switch (pname) {
     case GL_DELETE_STATUS:
@@ -3523,6 +4097,8 @@ ScriptValue WebGLRenderingContextBase::getProgramParameter(
 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program) {
   if (!ValidateWebGLProgramOrShader("getProgramInfoLog", program))
     return String();
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return String();
   GLStringQuery query(ContextGL());
   return query.Run<GLStringQuery::ProgramInfoLog>(ObjectNonZero(program));
 }
@@ -3533,6 +4109,8 @@ ScriptValue WebGLRenderingContextBase::getRenderbufferParameter(
     GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
   if (target != GL_RENDERBUFFER) {
     SynthesizeGLError(GL_INVALID_ENUM, "getRenderbufferParameter",
                       "invalid target");
@@ -3578,6 +4156,8 @@ ScriptValue WebGLRenderingContextBase::getShaderParameter(
     ScriptState* script_state,
     WebGLShader* shader,
     GLenum pname) {
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
   if (!ValidateWebGLProgramOrShader("getShaderParameter", shader)) {
     return ScriptValue::CreateNull(script_state->GetIsolate());
   }
@@ -3609,6 +4189,8 @@ ScriptValue WebGLRenderingContextBase::getShaderParameter(
 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader) {
   if (!ValidateWebGLProgramOrShader("getShaderInfoLog", shader))
     return String();
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return String();
   GLStringQuery query(ContextGL());
   return query.Run<GLStringQuery::ShaderInfoLog>(ObjectNonZero(shader));
 }
@@ -3621,6 +4203,80 @@ WebGLShaderPrecisionFormat* WebGLRenderingContextBase::getShaderPrecisionFormat(
   if (!ValidateShaderType("getShaderPrecisionFormat", shader_type)) {
     return nullptr;
   }
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return nullptr;
+
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+  {
+    std::string precision_str;
+    switch (precision_type) {
+      case GL_LOW_FLOAT:
+        precision_str = "gl.LOW_FLOAT";
+        break;
+      case GL_MEDIUM_FLOAT:
+        precision_str = "gl.MEDIUM_FLOAT";
+        break;
+      case GL_HIGH_FLOAT:
+        precision_str = "gl.HIGH_FLOAT";
+        break;
+      case GL_LOW_INT:
+        precision_str = "gl.LOW_INT";
+        break;
+      case GL_MEDIUM_INT:
+        precision_str = "gl.MEDIUM_INT";
+        break;
+      case GL_HIGH_INT:
+        precision_str = "gl.HIGH_INT";
+        break;
+      default:
+        SynthesizeGLError(GL_INVALID_ENUM, "getShaderPrecisionFormat",
+                          "invalid precision type");
+        return nullptr;
+    }
+
+    std::string shader;
+    switch (shader_type) {
+      case GL_FRAGMENT_SHADER:
+        shader = "gl.FRAGMENT_SHADER";
+        break;
+      case GL_VERTEX_SHADER:
+        shader = "gl.VERTEX_SHADER";
+        break;
+      default:
+        break;
+    }
+
+    GLint range[2] = {0, 0};
+    GLint precision = 0;
+    ContextGL()->GetShaderPrecisionFormat(shader_type, precision_type, range,
+                                          &precision);
+    WebGLShaderPrecisionFormat* result =
+      MakeGarbageCollected<WebGLShaderPrecisionFormat>(range[0], range[1],
+                                                       precision);
+
+    brave_page_graph::PageGraph* page_graph =
+      canvas()->GetDocument().GetPageGraph();
+    if (page_graph != nullptr) {
+      std::vector<const String> args;
+      args.push_back(shader.c_str());
+      args.push_back(precision_str.c_str());
+      page_graph->RegisterWebAPICall(
+        "WebGLRenderingContext.getShaderPrecisionFormat", args);
+
+      std::stringstream buffer;
+      buffer << "rangeMin: " << result->rangeMin()
+        << ", rangeMax: " << result->rangeMax()
+        << ", precision: " << result->precision();
+
+      String res(buffer.str().c_str());
+      page_graph->RegisterWebAPIResult(
+        "WebGLRenderingContext.getShaderPrecisionFormat", res);
+    }
+
+    return result;
+  }
+// #endif
+
   switch (precision_type) {
     case GL_LOW_FLOAT:
     case GL_MEDIUM_FLOAT:
@@ -3646,6 +4302,8 @@ WebGLShaderPrecisionFormat* WebGLRenderingContextBase::getShaderPrecisionFormat(
 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader) {
   if (!ValidateWebGLProgramOrShader("getShaderSource", shader))
     return String();
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return String();
   return EnsureNotNull(shader->Source());
 }
 
@@ -3653,6 +4311,8 @@ base::Optional<Vector<String>>
 WebGLRenderingContextBase::getSupportedExtensions() {
   if (isContextLost())
     return base::nullopt;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return base::nullopt;
 
   Vector<String> result;
 
@@ -3675,6 +4335,8 @@ ScriptValue WebGLRenderingContextBase::getTexParameter(
     GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
   if (!ValidateTextureBinding("getTexParameter", target))
     return ScriptValue::CreateNull(script_state->GetIsolate());
   switch (pname) {
@@ -3709,6 +4371,8 @@ ScriptValue WebGLRenderingContextBase::getUniform(
     const WebGLUniformLocation* uniform_location) {
   if (!ValidateWebGLProgramOrShader("getUniform", program))
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
   DCHECK(uniform_location);
   if (uniform_location->Program() != program) {
     SynthesizeGLError(GL_INVALID_OPERATION, "getUniform",
@@ -3989,6 +4653,8 @@ WebGLUniformLocation* WebGLRenderingContextBase::getUniformLocation(
     const String& name) {
   if (!ValidateWebGLProgramOrShader("getUniformLocation", program))
     return nullptr;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return nullptr;
   if (!ValidateLocationLength("getUniformLocation", name))
     return nullptr;
   if (!ValidateString("getUniformLocation", name))
@@ -4013,6 +4679,8 @@ ScriptValue WebGLRenderingContextBase::getVertexAttrib(
     GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return ScriptValue::CreateNull(script_state->GetIsolate());
   if (index >= max_vertex_attribs_) {
     SynthesizeGLError(GL_INVALID_VALUE, "getVertexAttrib",
                       "index out of range");
@@ -4090,6 +4758,8 @@ int64_t WebGLRenderingContextBase::getVertexAttribOffset(GLuint index,
                                                          GLenum pname) {
   if (isContextLost())
     return 0;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return 0;
   GLvoid* result = nullptr;
   // NOTE: If pname is ever a value that returns more than 1 element
   // this will corrupt memory.
@@ -4437,6 +5107,8 @@ void WebGLRenderingContextBase::ReadPixelsHelper(GLint x,
                                                  int64_t offset) {
   if (isContextLost())
     return;
+  if (canvas() && !AllowFingerprinting(canvas()->GetDocument().GetFrame()))
+    return;
   // Due to WebGL's same-origin restrictions, it is not possible to
   // taint the origin using the WebGL API.
   DCHECK(Host()->OriginClean());
